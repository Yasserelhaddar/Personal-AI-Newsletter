"""Error handling agents for the newsletter workflow."""

from src.infrastructure.logging import get_logger
from src.models.state import (
    NewsletterGenerationState,
    ProcessingStage,
    ErrorSeverity,
    add_error,
    get_errors_by_stage,
)

logger = get_logger(__name__)


async def handle_collection_error(state: NewsletterGenerationState) -> NewsletterGenerationState:
    """Handle content collection errors with fallback strategies.

    Args:
        state: Current workflow state

    Returns:
        Updated workflow state with error handling
    """
    collection_errors = get_errors_by_stage(state, ProcessingStage.COLLECTION)

    logger.warning(
        "Handling content collection errors",
        user_id=state["user_profile"].user_id,
        errors_count=len(collection_errors),
    )

    try:
        # If we have some content, proceed with reduced expectations
        if state["raw_content"] and len(state["raw_content"]) >= 1:
            state["warnings"].append(
                f"Proceeding with limited content ({len(state['raw_content'])} items)"
            )
            logger.info(
                "Proceeding with limited content",
                user_id=state["user_profile"].user_id,
                content_count=len(state["raw_content"]),
            )
            return state

        # Create minimal fallback content
        from src.models.content import create_content_item, ContentSource, ContentType

        fallback_content = [
            create_content_item(
                title="Welcome to Your AI Newsletter",
                url="https://example.com/welcome",
                source=ContentSource.MANUAL,
                content_type=ContentType.ARTICLE,
                summary="Your personalized newsletter system is now active. We'll collect better content for your next newsletter.",
                metadata={"fallback": True},
            )
        ]

        state["raw_content"] = fallback_content
        state["warnings"].append("Using fallback content due to collection failure")

        logger.info(
            "Applied fallback content",
            user_id=state["user_profile"].user_id,
        )

        return state

    except Exception as e:
        add_error(
            state,
            ProcessingStage.COLLECTION,
            f"Error handling failed: {str(e)}",
            ErrorSeverity.CRITICAL,
            "ERROR_HANDLER_FAILED",
        )

        logger.error(
            "Collection error handler failed",
            user_id=state["user_profile"].user_id,
            error=str(e),
        )

        return state


async def handle_curation_error(state: NewsletterGenerationState) -> NewsletterGenerationState:
    """Handle content curation errors with fallback strategies.

    Args:
        state: Current workflow state

    Returns:
        Updated workflow state with error handling
    """
    curation_errors = get_errors_by_stage(state, ProcessingStage.CURATION)

    logger.warning(
        "Handling content curation errors",
        user_id=state["user_profile"].user_id,
        errors_count=len(curation_errors),
    )

    try:
        # Try simple curation fallback
        from src.models.content import (
            CuratedNewsletter,
            ContentSection,
            AnalyzedContent,
        )
        from datetime import datetime, timezone

        # Convert raw content to analyzed content with basic scoring
        analyzed_content = []
        for item in state["raw_content"][:state["user_profile"].max_articles]:
            analyzed = AnalyzedContent(
                content_item=item,
                relevance_score=0.7,  # Default relevance
                quality_score=0.6,   # Default quality
                ai_summary=item.summary or f"Article about {item.title}",
            )
            analyzed_content.append(analyzed)

        # Create simple newsletter structure
        main_section = ContentSection(
            title="Today's Highlights",
            description="Curated content for you",
            emoji="âš¡",
            articles=analyzed_content,
        )

        fallback_newsletter = CuratedNewsletter(
            subject_line=f"Your Daily Digest - {datetime.now().strftime('%B %d')}",
            greeting=f"Hello, {state['user_profile'].name}!",
            sections=[main_section],
            personalized_insights=[],
            quick_reads=[],
            footer_content="Generated by Personal AI Newsletter",
            generation_metadata={
                "fallback_curation": True,
                "error_recovery": True,
            },
        )

        state["curated_newsletter"] = fallback_newsletter
        state["warnings"].append("Used simple curation fallback")

        logger.info(
            "Applied curation fallback",
            user_id=state["user_profile"].user_id,
            articles_count=fallback_newsletter.total_articles,
        )

        return state

    except Exception as e:
        add_error(
            state,
            ProcessingStage.CURATION,
            f"Curation error handling failed: {str(e)}",
            ErrorSeverity.CRITICAL,
            "CURATION_ERROR_HANDLER_FAILED",
        )

        logger.error(
            "Curation error handler failed",
            user_id=state["user_profile"].user_id,
            error=str(e),
        )

        return state


async def handle_delivery_error(state: NewsletterGenerationState) -> NewsletterGenerationState:
    """Handle email delivery errors.

    Args:
        state: Current workflow state

    Returns:
        Updated workflow state with error handling
    """
    delivery_errors = get_errors_by_stage(state, ProcessingStage.DELIVERY)

    logger.warning(
        "Handling delivery errors",
        user_id=state["user_profile"].user_id,
        errors_count=len(delivery_errors),
    )

    try:
        # Log delivery failure for later retry
        state["warnings"].append("Newsletter generated but delivery failed - can be retried")

        # Update delivery result to indicate handling
        if state["delivery_result"]:
            state["delivery_result"].metadata["error_handled"] = True
            state["delivery_result"].metadata["can_retry"] = True

        logger.info(
            "Delivery error handled - newsletter ready for retry",
            user_id=state["user_profile"].user_id,
        )

        return state

    except Exception as e:
        add_error(
            state,
            ProcessingStage.DELIVERY,
            f"Delivery error handling failed: {str(e)}",
            ErrorSeverity.CRITICAL,
            "DELIVERY_ERROR_HANDLER_FAILED",
        )

        logger.error(
            "Delivery error handler failed",
            user_id=state["user_profile"].user_id,
            error=str(e),
        )

        return state


async def handle_critical_failure(state: NewsletterGenerationState) -> NewsletterGenerationState:
    """Handle critical workflow failures.

    Args:
        state: Current workflow state

    Returns:
        Updated workflow state with critical error handling
    """
    logger.error(
        "Handling critical workflow failure",
        user_id=state["user_profile"].user_id,
        errors_count=len(state["errors"]),
    )

    try:
        # Mark workflow as failed
        state["generation_metadata"].current_stage = ProcessingStage.FAILED
        state["generation_metadata"].end_time = state["generation_metadata"].start_time

        # Collect all critical errors
        critical_errors = [
            error for error in state["errors"]
            if error.severity == ErrorSeverity.CRITICAL
        ]

        # Log comprehensive failure information
        logger.error(
            "Critical workflow failure summary",
            user_id=state["user_profile"].user_id,
            critical_errors=[str(error) for error in critical_errors],
            all_errors=[str(error) for error in state["errors"]],
            warnings=state["warnings"],
            processing_time=state["generation_metadata"].total_processing_time,
        )

        # Store failure metadata
        state["workflow_context"]["failure_info"] = {
            "critical_errors": [str(error) for error in critical_errors],
            "total_errors": len(state["errors"]),
            "failure_stage": critical_errors[0].stage.value if critical_errors else "unknown",
            "can_retry": len(critical_errors) == 1,  # Single critical error might be retryable
        }

        return state

    except Exception as e:
        logger.critical(
            "Critical failure handler encountered error",
            user_id=state["user_profile"].user_id,
            handler_error=str(e),
            exc_info=True,
        )

        return state